# 加密与解密

作者: [段钢](https://book.douban.com/search/段钢)
出版社: 电子工业出版社
出品方: [博文视点](https://book.douban.com/series/42608?brand=1)
出版年: 2018-10-1
页数: 936
定价: 198
装帧: 平装
丛书: [安全技术大系](https://book.douban.com/series/29000)
ISBN: 9787121336928

![img](https://img3.doubanio.com/view/subject/s/public/s29833960.jpg)

## 内容简介

《加密与解密（第4版）》以加密与解密为切入点，讲述了软件安全领域的基础知识和技能，如调试技能、逆向分析、加密保护、外壳开发、虚拟机设计等。这些知识彼此联系，读者在掌握这些内容之后，很容易就能在漏洞分析、安全编程、病毒分析、软件保护等领域进行扩展。从就业的角度来说，掌握加密与解密的相关技术，可以提高自身的竞争能力；从个人成长的角度来说，研究软件安全技术有助于掌握一些系统底层知识，是提升职业技能的重要途径。作为一名合格的程序员，除了掌握需求分析、设计模式等外，如果能掌握一些系统底层知识、熟悉整个系统的底层结构，在工作中必将获益良多。

《加密与解密（第4版）》适合安全研究人员、软件调试人员、程序开发人员阅读，也可以作为高校信息安全相关专业的辅助教材。

## 目录

基础篇
第1章 基础知识 2
1.1 什么是加密与解密 2
1.1.1 软件的加密与解密 2
1.1.2 软件逆向工程 2
1.1.3 逆向分析技术 3
1.2 文本字符 4
1.2.1 ASCII与Unicode字符集 4
1.2.2 字节存储顺序 6
1.3 Windows操作系统 6
1.3.1 Win32 API函数 6
1.3.2 WOW64 9
1.3.3 Windows消息机制 9
1.3.4 虚拟内存 11
调试篇
第2章 动态分析技术 14
2.1 OllyDbg调试器 14
2.1.1 OllyDbg的界面 14
2.1.2 OllyDbg的配置 15
2.1.3 基本操作 16
2.1.4 常用断点 27
2.1.5 插件 35
2.1.6 Run trace 36
2.1.7 Hit trace 37
2.1.8 调试符号 37
2.1.9 加载程序 39
2.1.10 OllyDbg的常见问题 40
2.2 x64dbg调试器 42
2.3 MDebug调试器 44
2.3.1 MDebug的界面 44
2.3.2 表达式 45
2.3.3 调试 45
2.3.4 断点 46
2.3.5 MDebug的其他功能 47
2.4 WinDbg调试器 47
2.4.1 WinDbg的安装与配置 47
2.4.2 调试过程 51
2.4.3 断点命令 51
2.4.4 栈窗口 53
2.4.5 内存命令 55
2.4.6 脚本 56
2.4.7 调试功能扩展 58
2.4.8 小结 59
第3章 静态分析技术 60
3.1 文件类型分析 60
3.2 反汇编引擎 61
3.2.1 OllyDbg的ODDisasm 61
3.2.2 BeaEngine 61
3.2.3 Udis86 61
3.2.4 Capstone 62
3.2.5 AsmJit 63
3.2.6 Keystone 64
3.2.7 小结 64
3.3 静态反汇编 65
3.3.1 IDA Pro简介 65
3.3.2 IDA的配置 66
3.3.3 IDA主窗口 68
3.3.4 交叉参考 69
3.3.5 参考重命名 70
3.3.6 标签的用法 71
3.3.7 格式化指令操作数 71
3.3.8 函数的操作 72
3.3.9 代码和数据转换 72
3.3.10 字符串 73
3.3.11 数组 74
3.3.12 结构体 75
3.3.13 枚举类型 79
3.3.14 变量 80
3.3.15 FLIRT 81
3.3.16 IDC脚本 82
3.3.17 插件 86
3.3.18 IDA调试器 87
3.3.19 远程调试 90
3.3.20 其他功能 93
3.3.21 小结 94
3.4 十六进制工具 94
3.5 静态分析技术应用实例 97
3.5.1 解密初步 97
3.5.2 逆向工程初步 99
解密篇
第4章 逆向分析技术 102
4.1 32位软件逆向技术 102
4.1.1 启动函数 102
4.1.2 函数 103
4.1.3 数据结构 111
4.1.4 虚函数 115
4.1.5 控制语句 117
4.1.6 循环语句 124
4.1.7 数学运算符 125
4.1.8 文本字符串 128
4.1.9 指令修改技巧 130
4.2 64位软件逆向技术 131
4.2.1 寄存器 131
4.2.2 函数 132
4.2.3 数据结构 142
4.2.4 控制语句 145
4.2.5 循环语句 154
4.2.6 数学运算符 158
4.2.7 虚函数 169
4.2.8 小结 193
第5章 演示版保护技术 194
5.1 序列号保护方式 194
5.1.1 序列号保护机制 194
5.1.2 如何攻击序列号保护机制 195
5.1.3 字符串比较形式 197
5.1.4 制作注册机 198
5.2 警告窗口 203
5.3 时间限制 205
5.3.1 计时器 205
5.3.2 时间限制 205
5.3.3 拆解时间限制保护 206
5.4 菜单功能限制 207
5.4.1 相关函数 207
5.4.2 拆解菜单限制保护 208
5.5 KeyFile保护 208
5.5.1 相关API函数 208
5.5.2 拆解KeyFile保护 209
5.6 网络验证 213
5.6.1 相关函数 214
5.6.2 破解网络验证的一般思路 214
5.7 光盘检测 219
5.7.1 相关函数 219
5.7.2 拆解光盘保护 220
5.8 只运行1个实例 221
5.8.1 实现方法 221
5.8.2 实例 222
5.9 常用断点设置技巧 222
第6章 加密算法 223
6.1 单向散列算法 223
6.1.1 MD5算法 223
6.1.2 SHA算法 227
6.1.3 SM3密码杂凑算法 231
6.1.4 小结 231
6.2 对称加密算法 231
6.2.1 RC4流密码 231
6.2.2 TEA算法 233
6.2.3 IDEA算法 236
6.2.4 BlowFish算法 243
6.2.5 AES算法 246
6.2.6 SM4分组密码算法 259
6.2.7 小结 259
6.3 公开密钥加密算法 259
6.3.1 RSA算法 260
6.3.2 ElGamal公钥算法 264
6.3.3 DSA数字签名算法 270
6.3.4 椭圆曲线密码编码学 272
6.3.5 SM2算法 279
6.4 其他算法 279
6.4.1 CRC32算法 279
6.4.2 Base64编码 280
6.5 常见的加密库接口及其识别 281
6.5.1 Miracl大数运算库 281
6.5.2 FGInt 283
6.5.3 其他加密算法库介绍 284
6.6 加密算法在软件保护中的应用 285
系统篇
第7章 Windows内核基础 290
7.1 内核理论基础 290
7.1.1 权限级别 290
7.1.2 内存空间布局 291
7.1.3 Windows与内核启动过程 292
7.1.4 Windows R3与R0通信 294
7.1.5 内核函数 296
7.1.6 内核驱动模块 297
7.2 内核重要数据结构 298
7.2.1 内核对象 298
7.2.2 SSDT 300
7.2.3 TEB 302
7.2.4 PEB 304
7.3 内核调试基础 306
7.3.1 使用WinDbg搭建双机调试环境 306
7.3.2 加载内核驱动并设置符号表 308
7.3.3 SSDT与Shadow SSDT的查看 311
第8章 Windows下的异常处理 313
8.1 异常处理的基本概念 313
8.1.1 异常列表 313
8.1.2 异常处理的基本过程 314
8.2 SEH的概念及基本知识 319
8.2.1 SEH的相关数据结构 319
8.2.2 SEH处理程序的安装和卸载 320
8.2.3 SEH实例跟踪 321
8.3 SEH异常处理程序原理及设计 325
8.3.1 异常分发的详细过程 325
8.3.2 线程异常处理 330
8.3.3 异常处理的栈展开 336
8.3.4 MSC编译器对线程异常处理的增强 342
8.3.5 顶层异常处理 349
8.3.6 异常处理程序的安全性 357
8.4 向量化异常处理 361
8.4.1 向量化异常处理的使用 361
8.4.2 VEH与SEH的异同 362
8.4.3 向量化异常处理的新内容 363
8.5 x64平台上的异常处理 363
8.5.1 原生x64程序的异常分发 364
8.5.2 WOW64下的异常分发 366
8.6 异常处理程序设计中的注意事项 367
8.7 异常处理的实际应用 368
8.7.1 使用SEH对用户输入进行验证 368
8.7.2 SEH在加密与解密中的应用 369
8.7.3 用VEH实现API Hook 371
8.8 本章小结 371
第9章 Win32调试API 372
9.1 调试相关函数简要说明 372
9.2 调试事件 375
9.3 创建并跟踪进程 377
9.4 调试循环体 378
9.5 处理调试事件 379
9.6 线程环境 380
9.7 将代码注入进程 382
第10章 VT技术 384
10.1 硬件虚拟化的基本概念 384
10.1.1 概述 384
10.1.2 相关结构和汇编指令 385
10.1.3 EPT机制 388
10.2 VT技术的应用 389
10.2.1 编译运行ShadowWalker 389
10.2.2 分析Hypervisor 390
10.2.3 检测VT支持情况 392
10.2.4 VMCS的配置 393
10.2.5 EPT的配置 396
10.2.6 开启VT 399
10.2.7 内存隐藏的实现 399
10.3 VT调试方法 401
第11章 PE文件格式 404
11.1 PE的基本概念 405
11.1.1 基地址 405
11.1.2 虚拟地址 406
11.1.3 相对虚拟地址 406
11.1.4 文件偏移地址 407
11.2 MS-DOS头部 407
11.3 PE文件头 408
11.3.1 Signature字段 408
11.3.2 IMAGE_FILE_HEADER结构 409
11.3.3 IMAGE_OPTIONAL_HEADER结构 410
11.4 区块 415
11.4.1 区块表 415
11.4.2 常见区块与区块合并 417
11.4.3 区块的对齐值 419
11.4.4 文件偏移与虚拟地址的转换 419
11.5 输入表 421
11.5.1 输入函数的调用 421
11.5.2 输入表的结构 422
11.5.3 输入地址表 424
11.5.4 输入表实例分析 424
11.6 绑定输入 428
11.7 输出表 429
11.7.1 输出表的结构 430
11.7.2 输出表实例分析 431
11.8 基址重定位 432
11.8.1 基址重定位的概念 432
11.8.2 基址重定位表的结构 433
11.8.3 基址重定位表实例分析 434
11.9 资源 435
11.9.1 资源结构 435
11.9.2 资源结构实例分析 438
11.9.3 资源编辑工具 440
11.10 TLS初始化 440
11.11 调试目录 441
11.12 延迟载入数据 441
11.13 程序异常数据 442
11.14 .NET头部 442
11.15 编写PE分析工具 443
11.15.1 检查文件格式 443
11.15.2 读取FileHeader和OptionalHeader的内容 444
11.15.3 得到数据目录表信息 445
11.15.4 得到区块表信息 446
11.15.5 得到输出表信息 447
11.15.6 得到输入表信息 448
第12章 注入技术 450
12.1 DLL注入方法 450
12.1.1 通过干预输入表处理过程加载目标DLL 450
12.1.2 改变程序运行流程使其主动加载目标DLL 466
12.1.3 利用系统机制加载DLL 484
12.2 DLL注入的应用 491
12.3 DLL注入的防范 491
12.3.1 驱动层防范 491
12.3.2 应用层防范 493
第13章 Hook技术 497
13.1 Hook概述 497
13.1.1 IAT Hook篡改MessageBox消息 497
13.1.2 Inline Hook篡改指定MessageBox消息 499
13.2 Hook的分类 500
13.2.1 Address Hook 501
13.2.2 Inline Hook 511
13.2.3 基于异常处理的Hook 513
13.2.4 不是Hook的Hook 514
13.3 Hook位置的挑选 515
13.4 Hook的典型过程 519
13.4.1 Address Hook的实施过程 519
13.4.2 Inline Hook的实施过程 526
13.4.3 基于异常处理的Hook实施过程 529
13.4.4 二次Hook的注意事项 532
13.4.5 通用Hook引擎的实现 533
13.5 Detour函数的典型用法 533
13.6 Hook中的注意事项 536
13.7 Hook在x64平台上的新问题 541
13.8 Hook技术的应用 543
13.9 Hook的检测、恢复与对抗 544
13.9.1 Hook的检测与恢复 544
13.9.2 Hook的对抗 545
13.10 本章小结 546
漏洞篇
第14章 漏洞分析技术 548
14.1 软件漏洞原理 548
14.1.1 缓冲区溢出漏洞 548
14.1.2 整型溢出漏洞 553
14.1.3 UAF漏洞 555
14.2 Shellcode 555
14.2.1 Shellcode的结构 556
14.2.2 Shellcode通用技术 559
14.2.3 实战Shellcode编写 560
14.3 漏洞利用 566
14.3.1 漏洞利用基本技术 567
14.3.2 漏洞利用高级技术 570
14.4 漏洞样本 572
14.5 样本分析 573
14.5.1 准备工作 573
14.5.2 静态分析 574
14.5.3 动态调试 576
14.5.4 追根溯源 581
14.5.5 小结 585
脱壳篇
第15章 专用加密软件 588
15.1 认识壳 588
15.1.1 壳的概念 588
15.1.2 压缩引擎 589
15.2 压缩壳 589
15.2.1 UPX 589
15.2.2 ASPack 590
15.3 加密壳 590
15.3.1 ASProtect 590
15.3.2 Armadillo 590
15.3.3 EXECryptor 591
15.3.4 Themida 591
15.4 虚拟机保护软件 592
15.4.1 虚拟机介绍 592
15.4.2 VMProtect简介 592
第16章 脱壳技术 594
16.1 基础知识 594
16.1.1 壳的加载过程 594
16.1.2 脱壳机 595
16.1.3 手动脱壳 596
16.2 寻找OEP 596
16.2.1 根据跨段指令寻找OEP 596
16.2.2 用内存访问断点寻找OEP 600
16.2.3 根据栈平衡原理寻找OEP 601
16.2.4 根据编译语言特点寻找OEP 602
16.3 抓取内存映像 603
16.3.1 Dump原理 603
16.3.2 反Dump技术 604
16.4 重建输入表 606
16.4.1 输入表重建的原理 606
16.4.2 确定IAT的地址和大小 607
16.4.3 根据IAT重建输入表 608
16.4.4 用Import REC重建输入表 611
16.4.5 输入表加密概括 614
16.5 DLL文件脱壳 615
16.5.1 寻找OEP 615
16.5.2 Dump映像文件 617
16.5.3 重建DLL的输入表 618
16.5.4 构造重定位表 619
16.6 附加数据 621
16.7 PE文件的优化 623
16.8 压缩壳 626
16.8.1 UPX外壳 626
16.8.2 ASPack外壳 629
16.9 加密壳 633
16.10 静态脱壳 637
16.10.1 外壳Loader分析 637
16.10.2 编写静态脱壳器 641
保护篇
第17章 软件保护技术 644
17.1 防范算法求逆 644
17.1.1 基本概念 644
17.1.2 堡垒战术 645
17.1.3 游击战术 646
17.2 抵御静态分析 647
17.2.1 花指令 647
17.2.2 SMC技术实现 649
17.2.3 信息隐藏 653
17.2.4 简单的多态变形技术 654
17.3 文件完整性检验 655
17.3.1 磁盘文件校验的实现 655
17.3.2 校验和 657
17.3.3 内存映像校验 657
17.4 代码与数据结合 659
17.4.1 准备工作 660
17.4.2 加密算法的选用 661
17.4.3 手动加密代码 661
17.4.4 使 .text区块可写 662
17.5 关于软件保护的若干忠告 663
第18章 反跟踪技术 665
18.1 由BeingDebugged引发的蝴蝶效应 665
18.1.1 BeingDebugged 665
18.1.2 NtGlobalFlag 669
18.1.3 Heap Magic 671
18.1.4 从源头消灭BeingDebugged 676
18.2 回归Native：用户态的梦魇 676
18.2.1 CheckRemoteDebuggerPresent 677
18.2.2 ProcessDebugPort 677
18.2.3 ThreadHideFromDebugger 680
18.2.4 DebugObject 682
18.2.5 SystemKernelDebuggerInformation 686
18.2.6 Native API 688
18.2.7 Hook和AntiHook 693
18.3 真正的奥秘：小技巧一览 696
18.3.1 SoftICE检测方法 696
18.3.2 OllyDbg检测方法 698
18.3.3 调试器漏洞 700
18.3.4 防止调试器附加 701
18.3.5 父进程检测 703
18.3.6 时间差 703
18.3.7 通过Trap Flag检测 704
18.3.8 双进程保护 704
第19章 外壳编写基础 705
19.1 外壳的结构 705
19.2 加壳主程序 706
19.2.1 判断文件是否为PE格式 706
19.2.2 文件基本数据读入 706
19.2.3 附加数据的读取 708
19.2.4 输入表的处理 708
19.2.5 重定位表的处理 711
19.2.6 文件的压缩 713
19.2.7 资源数据的处理 716
19.2.8 区块的融合 720
19.3 用汇编写外壳部分 721
19.3.1 外壳的加载过程 721
19.3.2 自建输入表 722
19.3.3 外壳引导段 723
19.3.4 外壳第2部分 726
19.3.5 将外壳部分添加至原程序 731
19.4 用C++编写外壳部分 734
第20章 虚拟机的设计 739
20.1 虚拟机保护技术原理 739
20.1.1 反汇编引擎 739
20.1.2 指令分类 739
20.2 启动框架和调用约定 740
20.2.1 调度器 740
20.2.2 虚拟环境 741
20.2.3 平衡栈vBegin和vCheckESP 742
20.3 Handler的设计 743
20.3.1 辅助Handler 743
20.3.2 普通Handler和指令拆解 744
20.3.3 标志位问题 745
20.3.4 相同作用的指令 745
20.3.5 转移指令 746
20.3.6 转移跳转指令的另一种实现 747
20.3.7 call指令 748
20.3.8 retn指令 748
20.3.9 不可模拟指令 749
20.4 托管代码的异常处理 749
20.4.1 VC++的异常处理 749
20.4.2 Delphi的异常处理 754
20.5 本章小结 757
第21章 VMProtect逆向和还原浅析 758
21.1 VMProtect逆向分析 758
21.1.1 VMProtect虚拟执行引擎的全景图 758
21.1.2 VMProtect虚拟引擎的基本架构 763
21.1.3 指令分类 763
21.2 VMProtect的还原 765
21.2.1 虚拟执行系统 766
21.2.2 生成完整的字节码流程图 767
21.2.3 给Handler命名并添加语义动作 774
21.2.4 将字节码的低级描述转换为中级描述 775
21.2.5 清除无用的字节码 776
21.2.6 用真值表化简逻辑指令 776
21.2.7 从特征中建立部分寄存器映射信息 779
21.2.8 其他无法确定的寄存器的图着色算法 785
21.2.9 使用DAG匹配生成指令 788
21.2.10 其他问题 791
软件重构篇
第22章 补丁技术 794
22.1 文件补丁 794
22.2 内存补丁 795
22.2.1 跨进程内存存取机制 795
22.2.2 Debug API机制 797
22.2.3 利用调试寄存器机制 800
22.2.4 利用DLL注入技术 803
22.2.5 利用Hook技术 807
22.2.6 利用VT技术 810
22.3 SMC补丁技术 813
22.3.1 单层SMC补丁技术 813
22.3.2 多层SMC补丁技术 814
22.4 补丁工具 816
第23章 代码的二次开发 818
23.1 数据对齐 818
23.2 增加空间 818
23.2.1 区块间隙 818
23.2.2 手动构造区块 819
23.2.3 工具辅助构造区块 820
23.3 获得函数的调用信息 820
23.3.1 增加输入函数 820
23.3.2 显式链接调用DLL 821
23.4 代码的重定位 822
23.4.1 修复重定位表 822
23.4.2 代码的自定位技术 824
23.5 增加输出函数 825
23.6 消息循环 826
23.6.1 WndProc函数 826
23.6.2 寻找消息循环 827
23.6.3 WndProc汇编形式 828
23.7 菜单扩展 829
23.7.1 扩充WndProc 829
23.7.2 扩充Exit菜单的功能 830
23.7.3 扩充Open菜单的功能 830
23.8 DLL扩展 833
23.8.1 扩展接口 833
23.8.2 扩展消息循环 834
语言和平台篇
第24章 .NET平台加解密 838
24.1 .NET概述 838
24.1.1 什么是 .NET 838
24.1.2 基本概念 839
24.1.3 第1个 .NET程序 840
24.2 MSIL与元数据 841
24.2.1 PE结构的扩展 841
24.2.2 .NET下的汇编MSIL 847
24.2.3 MSIL与元数据的结合 849
24.3 代码分析与修改技术 851
24.3.1 静态分析 851
24.3.2 动态调试 853
24.3.3 代码修改 855
24.4 .NET代码保护技术及其逆向 857
24.4.1 强名称 857
24.4.2 名称混淆 859
24.4.3 流程混淆 863
24.4.4 压缩 865
24.4.5 加密 869
24.4.6 其他保护手段 875
24.5 本章小结 876
取证篇
第25章 数据取证技术 878
25.1 硬盘数据的获取和固定 878
25.1.1 硬盘数据的获取 878
25.1.2 电子数据的固定 882
25.2 硬盘的分区和数据恢复 882
25.2.1 分区的解析 884
25.2.2 基于文件系统的数据恢复原理 886
25.3 内存分析 890
25.3.1 内存镜像的获取 891
25.3.2 内存镜像的分析 894
25.4 动态仿真技术 897
25.4.1 仿真专用硬件 897
25.4.2 软件仿真 898
25.5 注册表 900
25.5.1 Hive文件 900
25.5.2 注册表中的时间 901
25.5.3 USB移动存储设备 902
25.6 文件格式 903
25.6.1 文件修复和特征码 903
25.6.2 基于文件的数据恢复技术 904
25.6.3 数据隐藏的分析 906
术语表 909
参考文献 911